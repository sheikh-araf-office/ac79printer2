#include "app_config.h"
#include "typedef.h"
#include "syscfg/syscfg_id.h"

//#define CONFIG_USER_DEBUG_ENABLE  //Âº?ÂêØuser_printf
//#define CONFIG_SDCARD_DEBUG_ENABLE  //Âº?ÂÖ≥SDÂç°ËÆ∞ÂΩïÊâìÂç∞‰ø°ÊÅ?
//#define CONFIG_NETWORK_DEBUG_ENABLE //ÂèØ‰ª•Ëß¶ÂèëÊâìÂç∞‰ø°ÊÅØ‰∏ä‰º†Âà∞ÊúçÂä°Âô®Á´?
//#define CONFIG_USB_DEBUG_ENABLE     //Âº?ÂÖ≥USBËôöÊãü‰∏≤Âè£ÊâìÂç∞‰ø°ÊÅØ


#if (defined CONFIG_DEBUG_ENABLE && defined CONFIG_NETWORK_DEBUG_ENABLE)
#include "os/os_api.h"
#include "spinlock.h"
#include "wifi/wifi_connect.h"
#include "device/device.h"
#include "http/http_cli.h"
#include "json_c/json_object.h"
extern unsigned int time_lapse(unsigned int *handle, unsigned int time_out);
extern int lwip_dhcp_bound(void);
extern struct json_object *json_tokener_parse(const char *str);
static u32 log_cnt, log_time_hdl;
static char log_part, uploading_log_flag;
static spinlock_t lock;
static char log_buf[100 * 1024];

static int tmp_cnt = 0;
static u8 mac[6];
static u8 keycode_legal = 0;
static u8 check_keycode_cnt = 0;
#define LOG_BRAND 	"jieli"
#define LOG_NAME 	"APP"
#define	LOG_VERSION	"1.0.0"
#define LOG_UUID	"12345678"
#define LOG_KEYCODE	""		//ÂÆ¢Êà∑ÈöèÊú∫Â°´ÂÜô12-16‰∏™Â≠óÁ¨¶‰∏≤ÔºåÁî®‰∫éÊó•ÂøóÊü•ËØ?

static void upload_log_task(void *priv)
{
#define LOG_BOUNDARY        			"----385424468743051437018271"
#define LOG_HTTP_HEAD_OPTION_TWO        \
    "POST /status/v1/log/file HTTP/1.1\r\n"\
    "cache-control: no-cache\r\n"\
    "Host: log.jieliapp.com\r\n"\
    "content-type: multipart/form-data; boundary="LOG_BOUNDARY"\r\n"\
    "content-length: %lu\r\n"\
    "Connection: close\r\n\r\n"

#define LOG_BODY_OPTION_THREE                                                     \
    "--"LOG_BOUNDARY"\r\n"                                                          \
    "Content-Disposition: form-data; name=\"file\"; filename=\"%s.txt\"\r\n"  \
    "Content-Type: text/plain\r\n\r\n"

#define LOG_BODY_OPTION_FOUR       \
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"filename\"\r\n\r\n"\
    "%s.txt"\
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"platform\"\r\n\r\n"\
    "device"\
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"brand\"\r\n\r\n"\
    ""LOG_BRAND""\
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"name\"\r\n\r\n"\
    ""LOG_NAME""\
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"version\"\r\n\r\n"\
    ""LOG_VERSION""\
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"mac\"\r\n\r\n"\
    "%s"\
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"uuid\"\r\n\r\n"\
    ""LOG_UUID""\
    "\r\n--"LOG_BOUNDARY"\r\n"\
    "Content-Disposition: form-data; name=\"keycode\"\r\n\r\n"\
    ""LOG_KEYCODE""\
    "\r\n--"LOG_BOUNDARY"--\r\n"

    int ret = 0;
    char http_body_begin[512] = {0};
    char user_head_buf[512] = {0};
    char http_body_end[1024] = {0};
    char recv_buf[1024] = {0};

    if (mac[0] == '\0') {
        wifi_get_mac(mac);
    }
    char temp_buf1[20] = {0}, temp_buf2[20] = {0};
    sprintf(temp_buf1, "%02x%02x%02x%02x%02x%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    sprintf(temp_buf2, "%s-%d", temp_buf1, tmp_cnt++);
    sprintf(http_body_begin, LOG_BODY_OPTION_THREE, temp_buf2);
    sprintf(http_body_end, LOG_BODY_OPTION_FOUR, temp_buf2, temp_buf1);



    httpcli_ctx ctx = {0};
    //mode dataÁöÑ‰º†ËæìÊñπÂº?
    int http_more_data_addr[3] = {0};
    int http_more_data_len[3 + 1] = {0};
    http_more_data_addr[0] = (int)(http_body_begin);
    http_more_data_addr[1] = (int)log_buf;
    http_more_data_addr[2] = (int)(http_body_end);
    http_more_data_len[0] = strlen(http_body_begin);
    http_more_data_len[1] = strlen(log_buf);
    http_more_data_len[2] = strlen(http_body_end);
    http_more_data_len[3] = 0;

    ctx.more_data = http_more_data_addr;
    ctx.more_data_len = http_more_data_len;

    http_body_obj http_recv_body = {0};
    http_recv_body.recv_len = 0;
    http_recv_body.buf_len = 1024;
    http_recv_body.buf_count = 1;
    http_recv_body.p = recv_buf;

    ctx.timeout_millsec = 5000;
    ctx.priv = &http_recv_body;
    ctx.url = "http://log.jieliapp.com/status/v1/log/file";

    sprintf(user_head_buf, LOG_HTTP_HEAD_OPTION_TWO,  strlen(http_body_begin) + strlen(log_buf) + strlen(http_body_end));
    ctx.user_http_header = user_head_buf;
    ret = httpcli_post(&ctx);
    /*  extern void efgh(int i); */
    /* if (ret) { */
    /* efgh(1); */
    /* } else { */
    /* efgh(0); */
    /* } */


    memset(log_buf, 0, sizeof(log_buf));
    log_cnt = 0;



    uploading_log_flag = 0;
}

static void check_keycode(void)
{
    char url[128] = {0};
    char recv_buf[1024] = {0};
    http_body_obj http_recv_body = {0};
    http_recv_body.recv_len = 0;
    http_recv_body.buf_len = 1024;
    http_recv_body.buf_count = 1;
    http_recv_body.p = recv_buf;
    httpcli_ctx ctx = {0};
    sprintf(url, "http://log.jieliapp.com/status/v1/log/keycode/check?keycode=%s", LOG_KEYCODE);
    ctx.timeout_millsec = 5000;
    ctx.priv = &http_recv_body;
    ctx.url = url;
    ctx.connection = "close";
    httpcli_post(&ctx);
    json_object *root_node = NULL, *first_node = NULL, *second_node = NULL;
    root_node = json_tokener_parse((unsigned char *)http_recv_body.p);
    if (strcmp(json_object_get_string(json_object_object_get(root_node, "data")), "true") == 0) {
        keycode_legal = 1;
    }
    json_object_put(root_node);

}


void upload_log_trig(void)
{
    if (!lwip_dhcp_bound()) {
        return;
    }

    while (keycode_legal == 0 && check_keycode_cnt < 5) {
        check_keycode();
        check_keycode_cnt++;
    }
    if (keycode_legal == 1) {
        spin_lock(&lock);
        if (!uploading_log_flag) {
            uploading_log_flag = 1;
            spin_unlock(&lock);
            if (thread_fork("upload_log_task", 11, 2048, 0, 0, upload_log_task, NULL)) {
                uploading_log_flag = 0;
            }
            return;
        }
        spin_unlock(&lock);
    }
}

#endif



#if (defined CONFIG_DEBUG_ENABLE && defined CONFIG_SDCARD_DEBUG_ENABLE)
#include "system/includes.h"//cbuffer_t
#include "os/os_api.h"//ÂàõÂª∫Á∫øÁ®ãÔºåÁ≥ªÁªüÂª∂Êó?
#include "storage_device.h"//Ê£?Êü•SDÂç?
#include "system/init.h"//early_initcall
#include "fs/fs.h"//Êìç‰ΩúÂÜôÊñá‰ª?

/* ÂÆö‰πâÂàùÂßãÂåñÂæ™ÁéØBUFÁöÑÂ§ßÂ∞? */
#define DATA_BUF_SIZE (20*1024)
/* CBUFÊï∞ÊçÆÂ§ö‰∫éDATA_BUF_SIZE/2Â∞±ÂÜôÂÖ•‰∏ÄÊ¨°Êï∞Êç? */
#define WRITE_SIZE     (DATA_BUF_SIZE/2)

static char lg_buf[DATA_BUF_SIZE]; //ÊâìÂç∞‰ø°ÊÅØÁºìÂ≠òbuf
static u8 write_index;  	       //ËÆ∞ÂΩïÂÜôÁöÑ‰πí‰πìbufÁöÑ‰ΩçÁΩ?
static u8 write_busy;              //SDÂç°ÂÜôÂøôÁ¢åÁä∂Ê??
static OS_SEM sd_log_sem;

static void change_file_name(char *file_name, int len)
{
    u32 log_num = 0;           //Êñá‰ª∂Â∫èÂè∑ÂèòÈáè
    syscfg_read(VM_SD_LOG_INDEX, &log_num, sizeof(log_num)); //‰ªéVMËØªÂá∫
    snprintf(file_name, len, CONFIG_ROOT_PATH"log%u.txt", log_num);
    log_num++;
    syscfg_write(VM_SD_LOG_INDEX, &log_num, sizeof(log_num)); //‰ªéVMÂÜôÂÖ•
}
static int write_log_to_sd(const char *file_name, char *data, u32 len, u32 write_count, u8 index)
{
    FILE *file = fopen(file_name, "w");
    if (!file) {
        file = fopen(file_name, "w+");
        if (!file) {
            return -1;
        }
    }
    fseek(file, write_count * len, SEEK_SET);
    fwrite(index ? data : (data + len), len, 1, file);
    fclose(file);
    return 0;
}
static void sd_log_task(void *priv)
{
    u32 write_count = 0;               //ËÆ∞ÂΩïÂÜôÁöÑÊÄªÊ¨°Êï?
    u8 last_write_time = 0xff;
    u8 sd_state = 0;
    char file_name[64];

    change_file_name(file_name, sizeof(file_name));

    while (1) {
        if (!storage_device_ready()) { //SDÂç°Êú™Â∞±Áª™
            if (sd_state) {
                sd_state = 0;
                /* write_busy = 0; //Ê∏ÖÁ©∫Ê†áËÆ∞‰Ω? */
                write_count = 0;
                last_write_time = 0xff;
                change_file_name(file_name, sizeof(file_name));
            }
            os_time_dly(20);
        } else { //SDÂç°Â∞±Áª?
            sd_state = 1;

            if (last_write_time != write_index && write_busy) {
                write_busy = 0; //Ê†áËÆ∞Â∑≤ÁªèÂÜôÂÖ•Êï∞ÊçÆ
                last_write_time = write_index; //ËÆ∞ÂΩï‰∏ä‰∏ÄÂåÖÊï∞ÊçÆÂè∑
                if (0 == write_log_to_sd(file_name, lg_buf, WRITE_SIZE, write_count, write_index)) {
                    ++write_count;
                }
            }
            if (write_busy && last_write_time == write_index) { //Èú?Ë¶ÅÂÜôÂÖ•Êï∞ÊçÆÂπ∂‰∏îÊï∞ÊçÆÂåÖÂíå‰∏ä‰∏?ÂåÖ‰∏ÄÊ†?
                printf("SD_WRITE_[ERROR],Packet maybe loss!!!!!");
            }
            os_sem_pend(&sd_log_sem, 0);
        }
    }
}
static int sd_log_task_create(void)
{
#define SD_LOG_STK_SIZE 512
    static u8 sd_log_tcb_stk_q[sizeof(StaticTask_t) + SD_LOG_STK_SIZE * 4] ALIGNE(4);
    os_sem_create(&sd_log_sem, 0);
    os_task_create_static(sd_log_task, 0, 5, SD_LOG_STK_SIZE, 0, "sd_log_task", sd_log_tcb_stk_q);
    return 0;
}
module_initcall(sd_log_task_create);
#endif



#if (defined CONFIG_DEBUG_ENABLE && defined CONFIG_USB_DEBUG_ENABLE)
#include "os/os_api.h"//ÂàõÂª∫Á∫øÁ®ãÔºåÁ≥ªÁªüÂª∂Êó?
#include "system/init.h"//early_initcall

extern u32 cdc_write_data(int usb_id, u8 *buf, u32 len);

#define DATA_BUF_SIZE (200 * 1024)

static u32 lg_cnt, last_cnt;
static char lg_buf[DATA_BUF_SIZE]; //ÊâìÂç∞‰ø°ÊÅØÁºìÂ≠òÂÄ?

static void usb_log_task(void *priv)
{
    os_time_dly(300);

    while (1) {
        if (lg_cnt > last_cnt && last_cnt != lg_cnt) {
            if (lg_cnt / sizeof(lg_buf) > last_cnt / sizeof(lg_buf)) {
                cdc_write_data(0, (u8 *)lg_buf + (last_cnt % sizeof(lg_buf)), sizeof(lg_buf) - last_cnt % sizeof(lg_buf));
                cdc_write_data(1, (u8 *)lg_buf + (last_cnt % sizeof(lg_buf)), sizeof(lg_buf) - last_cnt % sizeof(lg_buf));
                cdc_write_data(0, (u8 *)lg_buf, lg_cnt - last_cnt - (sizeof(lg_buf) - last_cnt % sizeof(lg_buf)));
                cdc_write_data(1, (u8 *)lg_buf, lg_cnt - last_cnt - (sizeof(lg_buf) - last_cnt % sizeof(lg_buf)));
            } else {
                cdc_write_data(0, (u8 *)lg_buf + (last_cnt % sizeof(lg_buf)), lg_cnt - last_cnt);
                cdc_write_data(1, (u8 *)lg_buf + (last_cnt % sizeof(lg_buf)), lg_cnt - last_cnt);
            }
        }
        last_cnt = lg_cnt;
        os_time_dly(10);
    }
}

static int usb_log_task_create(void)
{
#define USB_LOG_STK_SIZE 256
    static u8 usb_log_tcb_stk_q[sizeof(StaticTask_t) + USB_LOG_STK_SIZE * 4 + sizeof(StaticQueue_t)] ALIGNE(4);
    return os_task_create_static(usb_log_task, 0, 1, USB_LOG_STK_SIZE, 0, "usb_log_task", usb_log_tcb_stk_q);
}
module_initcall(usb_log_task_create);
#endif



//////////////////////////////////////////

#if (defined CONFIG_NETWORK_DEBUG_ENABLE || defined CONFIG_SDCARD_DEBUG_ENABLE || defined CONFIG_USB_DEBUG_ENABLE)
void putbyte(char c)
{
#if defined CONFIG_NETWORK_DEBUG_ENABLE
    log_buf[(log_cnt++) % (sizeof(log_buf))] = c;
#endif
#if defined CONFIG_SDCARD_DEBUG_ENABLE
    static u32 lg_cnt = 0;         //ËÆ∞ÂΩïÊï∞ÊçÆ‰∏™Êï∞
    static u8 first_write = 1;
    u32 t = (lg_cnt++) % (sizeof(lg_buf));
    lg_buf[t] = c;
    if (!first_write && !(t % WRITE_SIZE)) {//Âà§Êñ≠t‰∏∫WRITE_SIZEÁöÑÊï¥Êï∞Â??
        write_busy = 1;//Ê†áËÆ∞Èú?Ë¶ÅÂÜôÂÖ•Êï∞Êç?
        write_index = t / WRITE_SIZE;//write_indexÂè™‰∏∫0Êà?1,‰∏?1Êó∂ÊòØÁ¨¨‰∏ÄÂåÖÊï∞Êç?,‰∏?0Êó∂ÊòØÁ¨¨‰∫åÂåÖÊï∞Êç?
        if (os_sem_valid(&sd_log_sem)) {
            os_sem_set(&sd_log_sem, 1);
            os_sem_post(&sd_log_sem);
        }
    }
    first_write = 0;
#endif
#if defined CONFIG_USB_DEBUG_ENABLE
    if (c == '\r') {
        return;
    }
    if (c == '\n') {
        lg_buf[(lg_cnt++) % (sizeof(lg_buf))] = '\r';
    }
    lg_buf[(lg_cnt++) % (sizeof(lg_buf))] = c;
#endif
}
#endif

#if (!defined CONFIG_DEBUG_ENABLE && !defined CONFIG_USER_DEBUG_ENABLE)
//ÂÖ≥Èó≠user_printfÁî®Êà∑ÊâìÂç∞
int user_putchar(int a)
{
    return a;
}
int user_puts(const char *out)
{
    return 0;
}
int user_printf(const char *format, ...)
{
    return 0;
}
int user_vprintf(const char *restrict format, va_list arg)
{
    return 0;
}
void user_put_buf(const u8 *buf, int len)
{
}
void user_put_u8hex(u8 dat)
{
}
void user_put_u16hex(u16 dat)
{
}
void user_put_u32hex(u32 dat)
{
}
#elif (defined CONFIG_USER_DEBUG_ENABLE)
int user_putchar(int a)//Áî®Êà∑ÁöÑuser_printf ÁöÑÂ∫ïÂ±ÇÂèëÈÄÅÂáΩÊï?
{
    putbyte(a);//ÂèØ‰ª•Êç¢Áî®Êà∑ÁöÑ‰∏≤Âè£ÂèëÈ?ÅÂáΩÊï?
    return a;
}
#endif

